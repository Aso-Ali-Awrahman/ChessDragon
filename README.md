# Chess-Dragon

### **Chess-Dragon**: a user base web application for pairing players in a tournament using (swiss) and (knockout) systems, from writing down the names of the players, pairing them according to the rule of the system, writing the score for each player after the round, and displaying the ranking from first to last.

### Database Functionality
* uses SQLite3 db for storing the user data.
* consists of two models apart from the built-in User model.
* VideoPost: stores the link of the YouTube video, only superusers can add a link, and the links will display on the community page.
* UserData: consists of three fields, user where each user can access the other data, swiss_data stores the data of the players in JSON format, and knockout_data also stores the data of the players in JSON format, but inside the JSON consists of two lists (white_players, black_players).
* JSON field example for the swiss_data:
data[name] = {
    "score": 0.0,
    "points": [],
    "color_list": [],
    "vs_players": [],
    "rounds": [],
    "color": {
        'last_played_color': '',
        'White': 0,
        'Black': 0
    }
} 
* JSON field example for the knockout_data: 
data = {
    'white_players': [],
    'black_players': []
}

<br>

### Back-End Functionality
* all functions are in views.py file.
* **file_handler**: used for handling the swiss_data in terms of read and write, has three parameters, action which represent either reading 'r' or writing 'w' the data, user to retrieve or update the swiss_data of the requested user, and obj which is used when the user wants to update the data of the players which is a dictionary. 
* **score_handler**: returns a list that consists of unique scores based on the player's scores from high to low, if there is data of the players.
* **is_logged_in**: a decorator used for 4 pages, simply checks if the user is authenticated, if it is then it can access the page, if not it will be redirected to the error page.
* **(home_page, community_page, error_page)**: those pages are mostly static apart from community pages which get all the links of the VideoPost model.
* **login_page**: used for logging the user to use the website features, when the user submits the form, checks if the user is authenticated, if it is it will redirect to the profile page. 
* **profile_page**: used for normal users that are not admin, if it is admin automatically redirects to the super_profile_page, if not it will render the profile page, the normal user in the profile page, can use the logout button to log out from the website.
* **super_profile_page**: only for admin users where they can (create users, delete users, view users, post links, delete links, view links, and log out) the admin can create normal users, and only view and delete normal users aswell.
* siwss system: three pages used for handling the swiss system (standing_page, tournament_page, and round_page).
* **standing_page**: displays the standing of the players from high to low, using file_handler and score_handler we get the data of the players and unique_scores, then rank them based on their score and the scores list, store all the info in the ranking dict, then we check the scores list for the print functionality.
* **tournament_page**: in the page consists of creating tournament by writing the names of the players, or by importing from excel file, also has reset standing for the players to reset the data of each player, then it can show the players as a dropdown button indivitualy to view more info, in the back end if the request is post, when the reset standing button is submited it will reset the dict of all of the players to default value, and a js pop up message apear after ward, if the submited button is create then we collect the name of the inputs as a list since all the inputs has same name, checks for any invalid length, then itterate over every name, and save it inside the data dict, also checks for the duplicate if there is then it will ad '_2', apart from writing the names manualy we can upload an excel file to the back end using upload-button, get the data of the sheet using pandas module we read the file, and then checks if 'Names' column is in the sheet, also checks the length of the Names it must be (2, 4, 8, 16, 32, 64, 128, ...) after that save each name in the data dict, all three post request after finishing their task use the file_handler to update the data, also when the scores list is at zero, it wont display the reset button since it all the players has default value.
* **round_page**: consists of three main post requests (pair, upload, and retirve), before that if the request is get using the file_handler we get the players info and check if there is any incomplete data in terms of length between the points list and vs_players, if there is the retrieve button will be activated on the page when loaded, if not just a pair button will apear, **first** the *retrive-button* will be activated when there is incomplete data that is caused by not uploading the scores of the round, this will result in incompletness of the info, the retrieve button will retrieve the last round simply by placing the players in the either white_players or black_players using their last item in the color_list to get the last round of pairing to be ready for uploading the score for each player, **second** the *upload-score-button* using the name of the inputs in the front end which is the player name that corresponds to their score we can get the score of each player based on their name, check if the input is correct, then assign the score to the points list, sum the score with the player score, and for the round list it must be like this (socre/last-item-color-list/last-item-vs_players), finally updates the data of the players using file_handler and redirect to standing page, **third** *pair-button* all of the logic and intense calculation is occuring in this post request where using score_handler we get the list of unique_scores, then we shuffle the data of the players so that the pairing is more random for some case, after that we rank them by score from high to low, those players who got higher socre than other will be on top, based on specific score we create a list and append all of the players that has this_score and then appended to the naming_lis_list, we ranked them based on score and now we pair them based on their last_played_color with an algorithim that can pair the players with the highest accurate pairing based color and the use of name_list_list, in this algorithim we have (final_pair_list, pair, and color_order), first using for loop we itterate of the name_list_list which give us a list in each itteration, check if the name_list length is not zero using while loop, after that using for loop itterate over the name_list to get the names and check if the last_played color of this name is equal to the color_order if it is appended to the pair list and remove the name from the name_list! and break the name_list for loop, if the last_played_color is '' this means it is the first round so it will do the same, if none of those where true the for loop will continue, after the loop the color_order will switch the color, since if the first player is white the next one should be black, after that we check if the pair length is two to appended to the final_pair_list, some times we don't have the color_order, that is ok since we aim at the highest accuarcy not 100%, the correct path is after white must be black but if not it is ok and vise versa since we use the color_order we can switch the color to append the name that has the same color, then using the while loop we check the length of the name_list, if it is not equal zero then there is still players(name) in that list we repeate the proccess till the length is zero, after the using the outer loop get the next name_list and so on.., finally the final_pair_list will consits of even number of matchs that each match is a list that consists of two players(names), after all of these logic calculations we can use the final_pair_list in a for loop to get th elist of two players to check their (last_played_color), if the last_played_color for both two players are same, we decide by which one has the least number of rounds with white color will be white in this round, if both have same number of rounds with white then we randomize their last_played_color', after this each player that is white last round will black in this round and vice versa, and fill the other data such as (color_list, and white or black count), finally we use a dict to store the white_players as a key and black_players as a value that corresponds to it's white_players, and fill the other data, and render the data in th efront end.
